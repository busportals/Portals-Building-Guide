name: Post Building Guide updates to Discord

on:
  push:

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Get commit diff
        id: diff
        run: |
          # Check if valid SHAs are available to avoid empty diff
          if [[ -n "${{ github.event.before }}" && -n "${{ github.event.after }}" ]]; then
            git diff ${{ github.event.before }} ${{ github.event.after }} > diff.txt
          else
            echo "No valid diff available" > diff.txt
          fi
          # Limit diff size to avoid token limits in OpenAI API
          DIFF=$(head -c 10000 diff.txt | sed ':a;N;$!ba;s/\n/\\n/g')
          echo "diff=$DIFF" >> $GITHUB_OUTPUT

      - name: Get changed files
        id: files
        run: |
          # Produce a name-status list for the commit range (e.g., A/M/R/D file.md)
          if [[ -n "${{ github.event.before }}" && -n "${{ github.event.after }}" ]]; then
            git diff --name-status ${{ github.event.before }} ${{ github.event.after }} > files.txt
          else
            echo "No files list available" > files.txt
          fi
          # Escape newlines for GitHub Actions outputs
          FILES=$(head -c 5000 files.txt | sed ':a;N;$!ba;s/\n/\\n/g')
          echo "files=$FILES" >> $GITHUB_OUTPUT

      - name: Generate AI summary
        id: summary
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          DIFF: ${{ steps.diff.outputs.diff }}
          FILES: ${{ steps.files.outputs.files }}
        run: |
          # Construct OpenAI API request payload with GitBook-focused guidance
          PAYLOAD=$(jq -nc \
            --arg system "You write public release notes for a GitBook documentation site (Markdown pages). Convert git changes into a concise, user‑facing 'Building Guide Update'. Rules:\n- Treat each *.md as a GitBook page, not a file.\n- Prefer page titles over filenames: use the first '# ' heading seen in the diff; otherwise derive a human title from the filename (drop '.md', replace '-'/'_' with spaces, Title Case).\n- Group items under sections: Added, Updated, Renamed, Removed (omit empty sections).\n- Focus on what changed for readers (e.g., 'Added fee wallet setting to Token Swap page'), not raw paths or code.\n- Be concise: 3–8 bullets total, under ~800 characters.\n- Do NOT wrap your answer in any quotation marks, code fences, or blockquotes.\n- Do NOT use '# ' headings; use bold for section names instead (e.g., **Added**, **Updated**), and do not restate the overall title.\n- If details are unclear, say 'Minor edits to existing pages.'\n" \
            --arg user "Changed files (name-status):\n$FILES\n\nUnified diff (may be truncated):\n$DIFF" \
            '{"model":"gpt-3.5-turbo","messages":[{"role":"system","content":$system},{"role":"user","content":$user}],"max_tokens":300,"temperature":0.2}')
          echo "DEBUG: PAYLOAD:"
          echo "$PAYLOAD"
          # Call OpenAI chat completions endpoint
          RESPONSE=$(curl -s \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" \
            https://api.openai.com/v1/chat/completions)
          echo "DEBUG: RESPONSE:"
          echo "$RESPONSE"
          # Extract the summary text
          SUMMARY=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')
          # Sanitize summary robustly with Python
          SANITIZED=$(SUMMARY="$SUMMARY" python3 - <<'PY'
          import os, re, sys
          s = os.environ.get("SUMMARY","")
          s = s.replace("\r\n","\n")
          # Drop leading/trailing blank lines
          s = "\n".join([ln for ln in s.splitlines() if ln is not None])
          s = s.strip()
          # Remove surrounding code fences if present
          if s.startswith("```") and s.endswith("```"):
              s = s.strip("`").strip()
          # Remove wrapping quotes/backticks if both ends match
          pairs = {'"':'"', '“':'”', "'":"'", '‘':'’', '`':'`'}
          if s and s[0] in pairs and s.rstrip().endswith(pairs[s[0]]):
              s = s[1:-1].strip()
          # Remove first line if it's a markdown heading
          lines = s.splitlines()
          while lines and not lines[0].strip():
              lines.pop(0)
          if lines and re.match(r'^\s{0,3}#{1,6}\s', lines[0]):
              lines.pop(0)
          s = "\n".join(lines).strip()
          # One more pass for stray wrapping quotes after trimming
          if s and s[0] in pairs and s.endswith(pairs[s[0]]):
              s = s[1:-1].strip()
          print(s)
          PY
          )
          SUMMARY="$SANITIZED"
          if [ "$SUMMARY" = "null" ] || [ -z "$SUMMARY" ]; then
            SUMMARY="AI summary unavailable; here are the changed files:\n\n$FILES"
          fi
          # Output for next steps
          echo "message=$(jq -Rs . <<< \"$SUMMARY\")" >> $GITHUB_OUTPUT

      - name: Send to Discord
        env:
          RAW_MESSAGE: ${{ steps.summary.outputs.message }}
        run: |
          # Strip surrounding JSON quotes and unescape newlines
          RAW_ESCAPED=${RAW_MESSAGE#\"}
          RAW_ESCAPED=${RAW_ESCAPED%\"}
          MESSAGE=$(printf '%b' "$RAW_ESCAPED")
          MESSAGE=$(printf '%s' "$MESSAGE" | sed -E '1s/^[[:space:]]*["“]+//; $s/["”]+[[:space:]]*$//')
          # Truncate message to fit Discord embed limits
          MESSAGE=$(echo "$MESSAGE" | head -c 2000)
          # Build JSON payload with full description
          PAYLOAD=$(jq -nc \
            --arg username "Portals" \
            --arg title "Building Guide Update" \
            --arg desc "$MESSAGE" \
            '{"username":$username,"embeds":[{"title":$title,"description":$desc,"color":3066993}]}')
          curl -H "Content-Type: application/json" \
               -d "$PAYLOAD" \
               "${{ secrets.DISCORD_WEBHOOK }}"